# -*- coding: utf-8 -*-
"""
generate_explicit_model.py

Reads Phase-2 artifacts in OUT_DIR and generates a single-file, explicit OpenSeesPy model:
    <OUT_DIR>/explicit_model.py

The explicit model file, when executed, will recreate the OpenSees domain with:
- All nodes (from nodes.json)
- Base supports (from supports.json)
- Rigid diaphragms (from diaphragms.json), including master-node mass() and fix()
- Columns and beams (from columns.json, beams.json) with their recorded section/transf properties

Assumptions (aligned with repo):
- Deterministic node tags: node_tag = point_id*1000 + story_index (0 = top, increasing downward)
- Artifacts match the schemas emitted by columns.py, beams.py, diaphragms.py, emit_nodes.py, supports.py

Usage:
    python generate_explicit_model.py --out out --explicit out/explicit_model.py
    # then
    python out/explicit_model.py

Generator: Python 3.11+. Emitted file: Python 3.8+ compatible.
"""
from __future__ import annotations

import argparse
import json
import os
from typing import Any, Dict, Iterable, List, Set, Tuple


# Prefer project config
try:
    from config import OUT_DIR  # type: ignore
except Exception:
    OUT_DIR = "out"


# ----------------------------
# Helpers (robust JSON loading)
# ----------------------------
def _load_json(path: str) -> Dict[str, Any] | None:
    if not os.path.exists(path):
        print(f"[explicit-gen] WARN: missing {path}")
        return None
    with open(path, "r", encoding="utf-8") as f:
        try:
            return json.load(f)
        except Exception as e:
            print(f"[explicit-gen] ERROR: failed to parse {path}: {e}")
            return None


def _as_float(val: Any, default: float = 0.0) -> float:
    try:
        if val is None:
            return default
        return float(val)
    except Exception:
        return default


def _as_int(val: Any, default: int = 0) -> int:
    try:
        if val is None:
            return default
        return int(val)
    except Exception:
        return default


def _dedupe_sorted_by_key(items: Iterable[Dict[str, Any]], key: str) -> List[Dict[str, Any]]:
    seen: Set[int] = set()
    out: List[Dict[str, Any]] = []
    for rec in sorted(items, key=lambda r: _as_int(r.get(key, 0))):
        tag = _as_int(rec.get(key, 0))
        if tag in seen:
            continue
        seen.add(tag)
        out.append(rec)
    return out


# ------------------------------------------
# Emitters (return strings already indented)
# ------------------------------------------
def _emit_header(ndm: int, ndf: int) -> str:
    # Emit annotations safe for Python 3.8+ in the generated file (no built-in generics like list[int])
    return (
        "# -*- coding: utf-8 -*-\n"
        "\"\"\"\n"
        "explicit_model.py\n"
        "AUTOGENERATED by generate_explicit_model.py. Do not edit by hand.\n"
        "\n"
        "This file recreates the OpenSees domain from Phase-2 artifacts.\n"
        "\"\"\"\n"
        "from openseespy.opensees import wipe, model, node, fix, mass, geomTransf, element\n"
        "# Rigid diaphragm import (version differences handled)\n"
        "try:\n"
        "    from openseespy.opensees import rigidDiaphragm as _rigid\n"
        "    _HAVE_RIGID = True\n"
        "except Exception:\n"
        "    _HAVE_RIGID = False\n"
        "\n"
        "def _call_rigid(master: int, slaves: list) -> None:\n"
        "    \"\"\"Invoke rigid diaphragm constraint with a signature that works across OpenSeesPy versions.\"\"\"\n"
        "    if not _HAVE_RIGID:\n"
        "        print(\"[explicit] WARN: rigidDiaphragm not available\")\n"
        "        return\n"
        "    try:\n"
        "        _rigid(3, master, *slaves)\n"
        "    except TypeError:\n"
        "        # Legacy signature fallback\n"
        "        _rigid(master, *slaves)\n"
        "\n"
        f"def build_model(ndm: int = {ndm}, ndf: int = {ndf}) -> None:\n"
        "    wipe()\n"
        "    model('Basic', '-ndm', ndm, '-ndf', ndf)\n"
    )


def _emit_nodes(nodes_raw: List[Dict[str, Any]]) -> str:
    nodes = _dedupe_sorted_by_key(nodes_raw, "tag")
    lines: List[str] = []
    lines.append(f"    # --- Nodes ({len(nodes)}) ---")
    for rec in nodes:
        tag = _as_int(rec.get("tag"))
        x = _as_float(rec.get("x"))
        y = _as_float(rec.get("y"))
        z = _as_float(rec.get("z"))
        lines.append(f"    node({tag}, {x:.6f}, {y:.6f}, {z:.6f})")
    return "\n".join(lines) + "\n"


def _emit_supports(sp: Dict[str, Any] | None) -> str:
    if not sp:
        return "    # --- Supports (0) ---\n"
    # supports.json may store either a compact mask list or named dict
    applied = sp.get("applied") or []
    lines = [f"    # --- Supports ({len(applied)}) ---"]
    for ent in applied:
        tag = _as_int(ent.get("node"))
        mask = ent.get("mask")
        if isinstance(mask, (list, tuple)) and len(mask) == 6:
            ux, uy, uz, rx, ry, rz = (int(v) for v in mask)
        elif isinstance(mask, dict):
            ux = _as_int(mask.get("ux"))
            uy = _as_int(mask.get("uy"))
            uz = _as_int(mask.get("uz"))
            rx = _as_int(mask.get("rx"))
            ry = _as_int(mask.get("ry"))
            rz = _as_int(mask.get("rz"))
        else:
            # safe default (no restraint)
            ux = uy = uz = rx = ry = rz = 0
        lines.append(f"    fix({tag}, {ux}, {uy}, {uz}, {rx}, {ry}, {rz})")
    return "\n".join(lines) + "\n"


def _emit_diaphragms(dg: Dict[str, Any] | None) -> str:
    if not dg:
        return "    # --- Rigid diaphragms (0) ---\n"
    ds = dg.get("diaphragms") or []
    lines = [f"    # --- Rigid diaphragms ({len(ds)}) ---"]
    for rec in ds:
        master = _as_int(rec.get("master"))
        mass_meta = rec.get("mass") or {}
        M = _as_float(mass_meta.get("M"))
        Izz = _as_float(mass_meta.get("Izz"))
        # Always apply mass & fix for correctness (aligns with spec)
        lines.append(f"    mass({master}, {M:.6f}, {M:.6f}, 0.0, 0.0, 0.0, {Izz:.6f})")
        lines.append(f"    fix({master}, 0, 0, 1, 1, 1, 0)")
        slaves = [ _as_int(s) for s in (rec.get("slaves") or []) ]
        if slaves:
            s_list = ", ".join(str(s) for s in slaves)
            lines.append(f"    _call_rigid({master}, [{s_list}])")
    return "\n".join(lines) + "\n"


def _collect_transf_tags(cols: Dict[str, Any] | None, beams: Dict[str, Any] | None) -> Set[int]:
    tags: Set[int] = set()
    if cols:
        for c in cols.get("columns", []):
            tags.add(_as_int(c.get("transf_tag"), 111))
    if beams:
        for b in beams.get("beams", []):
            tags.add(_as_int(b.get("transf_tag"), 222))
    return tags


def _emit_transforms(cols: Dict[str, Any] | None, beams: Dict[str, Any] | None) -> str:
    tags = sorted(_collect_transf_tags(cols, beams))
    lines: List[str] = ["    # --- Geometric transforms ---"]
    if not tags:
        lines.append("    # none required")
        return "\n".join(lines) + "\n"

    # Known conventions in this repo:
    # - 111 used by columns (vecXZ = 1,0,0)
    # - 222 used by beams   (vecXZ = 0,0,1)
    # Any other tag: default to vecXZ = 0,0,1 with a clear warning.
    for t in tags:
        if t == 111:
            lines.append("    geomTransf('Linear', 111, 1, 0, 0)  # columns")
        elif t == 222:
            lines.append("    geomTransf('Linear', 222, 0, 0, 1)  # beams")
        else:
            lines.append(f"    # WARN: Unknown transf_tag {t}; defaulting vecXZ to global Z")
            lines.append(f"    geomTransf('Linear', {t}, 0, 0, 1)")
    return "\n".join(lines) + "\n"


def _emit_columns(cols: Dict[str, Any] | None) -> str:
    if not cols:
        return "    # --- Columns (0) ---\n"
    items = _dedupe_sorted_by_key(cols.get("columns") or [], "tag")
    lines = [f"    # --- Columns ({len(items)}) ---"]
    for rec in items:
        tag = _as_int(rec.get("tag"))
        i_node = _as_int(rec.get("i_node"))
        j_node = _as_int(rec.get("j_node"))
        A = _as_float(rec.get("A"))
        E = _as_float(rec.get("E"))
        G = _as_float(rec.get("G"))
        J = _as_float(rec.get("J"))
        Iy = _as_float(rec.get("Iy"))
        Iz = _as_float(rec.get("Iz"))
        transf = _as_int(rec.get("transf_tag"), 111)
        lines.append(
            f"    element('elasticBeamColumn', {tag}, {i_node}, {j_node}, {A:.6f}, {E:.6f}, {G:.6f}, {J:.6f}, {Iy:.6f}, {Iz:.6f}, {transf})"
        )
    return "\n".join(lines) + "\n"


def _emit_beams(beams: Dict[str, Any] | None) -> str:
    if not beams:
        return "    # --- Beams (0) ---\n"
    items = _dedupe_sorted_by_key(beams.get("beams") or [], "tag")
    lines = [f"    # --- Beams ({len(items)}) ---"]
    for rec in items:
        tag = _as_int(rec.get("tag"))
        i_node = _as_int(rec.get("i_node"))
        j_node = _as_int(rec.get("j_node"))
        A = _as_float(rec.get("A"))
        E = _as_float(rec.get("E"))
        G = _as_float(rec.get("G"))
        J = _as_float(rec.get("J"))
        Iy = _as_float(rec.get("Iy"))
        Iz = _as_float(rec.get("Iz"))
        transf = _as_int(rec.get("transf_tag"), 222)
        lines.append(
            f"    element('elasticBeamColumn', {tag}, {i_node}, {j_node}, {A:.6f}, {E:.6f}, {G:.6f}, {J:.6f}, {Iy:.6f}, {Iz:.6f}, {transf})"
        )
    return "\n".join(lines) + "\n"


def _emit_footer() -> str:
    return (
        "    print(\"[explicit] Model built successfully.\")\n"
        "    # Optionally: add domain summary here (node/element counts).\n"
        "\n"
        "if __name__ == \"__main__\":\n"
        "    build_model()\n"
    )


# ---------------------------------------
# Main generator (reads JSON, writes file)
# ---------------------------------------
def generate_explicit_model(
    out_dir: str = OUT_DIR,
    explicit_path: str | None = None,
    *,
    ndm: int = 3,
    ndf: int = 6,
) -> str:
    """
    Generate the explicit OpenSeesPy model file from artifacts under `out_dir`.
    Returns the path to the written explicit file.
    """
    if explicit_path is None:
        explicit_path = os.path.join(out_dir, "explicit_model.py")

    # Load artifacts
    nj = _load_json(os.path.join(out_dir, "nodes.json"))
    sp = _load_json(os.path.join(out_dir, "supports.json"))
    dg = _load_json(os.path.join(out_dir, "diaphragms.json"))
    cj = _load_json(os.path.join(out_dir, "columns.json"))
    bj = _load_json(os.path.join(out_dir, "beams.json"))

    nodes = (nj or {}).get("nodes") or []

    # Compose the explicit model content.
    parts: List[str] = []
    parts.append(_emit_header(ndm, ndf))
    parts.append(_emit_nodes(nodes))
    parts.append(_emit_supports(sp))
    parts.append(_emit_diaphragms(dg))
    parts.append(_emit_transforms(cj, bj))
    parts.append(_emit_columns(cj))
    parts.append(_emit_beams(bj))
    parts.append(_emit_footer())

    text = "\n".join(parts)

    os.makedirs(out_dir, exist_ok=True)
    # newline='\n' ensures consistent line endings across platforms
    with open(explicit_path, "w", encoding="utf-8", newline="\n") as f:
        f.write(text)
    print(f"[explicit-gen] Wrote {explicit_path}")
    return explicit_path


def main() -> None:
    parser = argparse.ArgumentParser(description="Generate explicit OpenSeesPy model from artifacts.")
    parser.add_argument("--out", dest="out_dir", default=OUT_DIR, help="Artifacts directory (default from config.OUT_DIR or 'out')")
    parser.add_argument("--explicit", dest="explicit_path", default=None, help="Destination explicit model path")
    parser.add_argument("--ndm", type=int, default=3, help="Number of dimensions")
    parser.add_argument("--ndf", type=int, default=6, help="Number of DOFs per node")
    args = parser.parse_args()

    generate_explicit_model(args.out_dir, args.explicit_path, ndm=args.ndm, ndf=args.ndf)


if __name__ == "__main__":
    main()
